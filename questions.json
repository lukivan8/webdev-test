[
  {
    "id": 1,
    "question": "Функция receive_request() читает из сокета порциями по 1024 байта и ищет \\r\\n\\r\\n. Зачем это нужно?",
    "options": [
      "Для ускорения чтения данных",
      "TCP не гарантирует порядок байтов",
      "TCP передаёт поток байтов без границ сообщений",
      "Это требование HTTP/1.1 протокола",
      "Для поддержки Unicode символов"
    ],
    "correctIndex": 2
  },
  {
    "id": 2,
    "question": "Client отправил запрос размером 10KB. Сервер читает из сокета порциями по 1KB. Сколько вызовов socket.recv(1024) потребуется?",
    "options": [
      "Ровно 10, потому что 10KB / 1KB = 10",
      "Минимум 10, возможно больше если TCP разбил на сегменты",
      "1, потому что TCP буферизует всё",
      "Зависит от скорости интернета",
      "Невозможно определить без знания MTU"
    ],
    "correctIndex": 1
  },
  {
    "id": 3,
    "question": "В handle_client() есть цикл while keep_alive:. Что происходит если клиент отправил заголовок Connection: close?",
    "options": [
      "TCP соединение закрывается немедленно",
      "Сервер обрабатывает запрос и закрывает соединение после ответа",
      "Сервер возвращает ошибку 400",
      "Цикл продолжается, заголовок игнорируется",
      "Browser автоматически откроет новое соединение"
    ],
    "correctIndex": 1
  },
  {
    "id": 4,
    "question": "Функция receive_request() читает заголовки до \\r\\n\\r\\n, затем читает тело по Content-Length. Что произойдёт если Content-Length отсутствует в POST запросе?",
    "options": [
      "Сервер вернёт 411 Length Required",
      "Сервер не сможет определить где заканчивается тело",
      "TCP автоматически добавит длину",
      "Тело будет пустым",
      "Browser отправит запрос повторно"
    ],
    "correctIndex": 1
  },
  {
    "id": 5,
    "question": "Функция parse_http_request() парсит строку GET /catalog?sort=price HTTP/1.1. Что будет записано в request['method']?",
    "options": [
      "GET /catalog?sort=price",
      "GET",
      "/catalog?sort=price",
      "HTTP/1.1",
      "Вся строка целиком"
    ],
    "correctIndex": 1
  },
  {
    "id": 6,
    "question": "В format_http_response() тело ответа кодируется в байты и вычисляется его длина. Зачем нужен заголовок Content-Length?",
    "options": [
      "Для ускорения передачи",
      "Для валидации данных",
      "Чтобы клиент знал сколько байт читать из TCP потока",
      "Это требование только для POST запросов",
      "Для поддержки compression"
    ],
    "correctIndex": 2
  },
  {
    "id": 7,
    "question": "После добавления товара в корзину сервер возвращает 302 Found с Location: /cart. Что делает браузер?",
    "options": [
      "Показывает код 302 пользователю",
      "Автоматически отправляет GET запрос на /cart",
      "Отправляет POST запрос на /cart",
      "Закрывает соединение",
      "Ждёт подтверждения от пользователя"
    ],
    "correctIndex": 1
  },
  {
    "id": 8,
    "question": "Client отправил DELETE /api/cart/laptop. Что семантически означает этот запрос?",
    "options": [
      "Получить информацию о товаре laptop",
      "Удалить товар laptop из ресурса",
      "Обновить товар laptop",
      "Создать новый товар",
      "Переместить товар в другую корзину"
    ],
    "correctIndex": 1
  },
  {
    "id": 9,
    "question": "В URL /catalog?category=phones&sort=price что такое category=phones&sort=price?",
    "options": [
      "Path параметр",
      "Query string",
      "Request body",
      "Fragment identifier",
      "HTTP header"
    ],
    "correctIndex": 1
  },
  {
    "id": 10,
    "question": "Сервер устанавливает cookie через Set-Cookie: user=bob. Что делает браузер с последующими запросами?",
    "options": [
      "Игнорирует cookie",
      "Отправляет cookie только на HTTPS",
      "Автоматически добавляет заголовок Cookie: user=bob",
      "Запрашивает подтверждение у пользователя",
      "Сохраняет cookie только в памяти"
    ],
    "correctIndex": 2
  },
  {
    "id": 11,
    "question": "Client отправил запрос с заголовком Accept: application/json. Что это означает?",
    "options": [
      "Client отправляет JSON в теле",
      "Client ожидает JSON в ответе",
      "Server должен вернуть 406",
      "Это обязательный заголовок для POST",
      "Браузер поддерживает только JSON"
    ],
    "correctIndex": 1
  },
  {
    "id": 12,
    "question": "Почему GET запрос не должен изменять данные на сервере?",
    "options": [
      "Это техническое ограничение HTTP",
      "GET запросы не могут иметь тело",
      "Браузер может повторно отправить GET при обновлении страницы",
      "GET быстрее чем POST",
      "TCP не поддерживает изменение данных"
    ],
    "correctIndex": 2
  },
  {
    "id": 13,
    "question": "В проекте есть слои: tcp.py → http_parse.py → http_framework.py → main.py. Зачем такая структура?",
    "options": [
      "Для увеличения производительности",
      "Для разделения ответственности и уровней абстракции",
      "Это требование Python",
      "Для поддержки многопоточности",
      "Чтобы код был длиннее"
    ],
    "correctIndex": 1
  },
  {
    "id": 14,
    "question": "Функция router() получает список [(method, path, handler), ...]. Как она выбирает какой handler вызвать?",
    "options": [
      "Вызывает первый handler в списке",
      "Сопоставляет метод и путь запроса с зарегистрированными маршрутами",
      "Выбирает случайный handler",
      "Использует регулярные выражения",
      "Передаёт выбор браузеру"
    ],
    "correctIndex": 1
  },
  {
    "id": 15,
    "question": "Все handlers получают объект context = {\"store\": data}. Зачем передавать context?",
    "options": [
      "Для экономии памяти",
      "Чтобы разделять состояние между запросами без глобальных переменных",
      "Это требование HTTP",
      "Для поддержки многопоточности",
      "Чтобы избежать импортов"
    ],
    "correctIndex": 1
  },
  {
    "id": 16,
    "question": "API эндпоинт /api/catalog возвращает JSON. HTML страница /catalog возвращает HTML с теми же данными. Зачем нужны оба?",
    "options": [
      "Это ошибка дублирования",
      "API для программного доступа, HTML для браузера",
      "Для улучшения SEO",
      "JSON быстрее чем HTML",
      "Это требование REST"
    ],
    "correctIndex": 1
  },
  {
    "id": 17,
    "question": "В service.py есть функция add_to_cart() которая вызывается из handler в main.py. Зачем выносить логику в отдельный файл?",
    "options": [
      "Для увеличения скорости",
      "Для разделения бизнес-логики и транспортного слоя",
      "Это требование Python",
      "Чтобы избежать импортов",
      "Для поддержки тестирования"
    ],
    "correctIndex": 1
  },
  {
    "id": 18,
    "question": "Функция parse_template() заменяет {{title}} на значение из данных. Где выполняется эта замена?",
    "options": [
      "В браузере через JavaScript",
      "На сервере перед отправкой HTML",
      "В TCP слое",
      "В CSS файле",
      "Браузер делает это автоматически"
    ],
    "correctIndex": 1
  },
  {
    "id": 19,
    "question": "Чем отличается SSR страница /catalog от CSR страницы /csr при первой загрузке?",
    "options": [
      "SSR медленнее",
      "SSR отдаёт готовый HTML с контентом, CSR отдаёт пустой HTML и строит UI в браузере",
      "CSR не использует HTTP",
      "SSR требует JavaScript",
      "Никакой разницы для пользователя"
    ],
    "correctIndex": 1
  },
  {
    "id": 20,
    "question": "JavaScript делает fetch('DELETE', '/api/cart/laptop'). Что происходит на уровне HTTP?",
    "options": [
      "Browser блокирует DELETE запросы",
      "Отправляется HTTP запрос с методом DELETE",
      "DELETE автоматически конвертируется в POST",
      "Нужен специальный заголовок для DELETE",
      "TCP не поддерживает DELETE"
    ],
    "correctIndex": 1
  }
]
